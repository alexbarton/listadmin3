#!/usr/bin/python3
#
# Copyright 2023 Jonathan McDowell <noodles@earth.li>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program. If not, see <https://www.gnu.org/licenses/>.

"""
 listadmin3 is an unimaginatively named command line tool to manage Mailman3
 lists and process queues, without the need to go to the Mailman3 interface.
 It currently allows for the inspection of message moderation queues, allowing
 for messages to be accepted or discarded manually. It is inspired by
 listadmin, which is a much more fully featured tool that operates on Mailman 2
 lists.
"""

import os
import json
import sys
import termios
import tty

import mechanicalsoup # type: ignore

class HTMLParseError(Exception):
    """ Exception class for reporting HTML parse errors """


class Mailman3UI:
    """ Class allowing interactions with the Mailman3 web interface """
    def __init__(self, url, username, password):
        self._browser = mechanicalsoup.StatefulBrowser(
            soup_config={'features': 'lxml'},
            user_agent='listadmin3/0.1',
        )
        self._baseurl = url
        self._username = username
        self._password = password

    def login(self):
        """ Logs in to the Mailman3 instance """
        self._browser.open(self._baseurl + 'accounts/login/')
        self._browser.select_form(selector='form.login')
        self._browser["login"] = self._username
        self._browser["password"] = self._password
        self._browser.submit_selected()

    def logout(self):
        """ Logs out of the Mailman3 instance """
        self._browser.open(self._baseurl + 'accounts/logout/')

    def get_held_messages(self, listname: str) -> list[dict]:
        """ Get a list of held messages for the supplied listname """
        page = self._browser.open(self._baseurl + 'postorius/lists/' + listname + '/held_messages')

        count_select = page.soup.find("select", attrs={'name': 'count'})
        if not count_select:
            # Assume no held messages (could check for "There are currently no held messages."
            # message)
            return []
        count_form = count_select.parent
        count = 10
        for option in count_select.find_all('option'):
            if 'selected' in option.attrs:
                count = option['value']
        if count != 200:
            count_form = self._browser.select_form(selector=count_form)
            count_form.set_select({'count': 200})
            page = self._browser.submit_selected()

        msg_form = page.soup.find("h2")
        if msg_form.text.strip() != "Held Messages":
            raise HTMLParseError("Couldn't find held message list")
        msg_form = msg_form.find_next_sibling("form")
        msg_list = msg_form.find("tbody")
        msgs = []
        for msg_row in msg_list.find_all("tr"):
            msg = {}
            row_data = msg_row.find("td")
            msg_id = row_data.find("input")
            msg['id'] = msg_id['value']
            row_data = row_data.find_next_sibling("td")
            subject = row_data.find("a")
            msg["subject"] = subject.text.strip()
            row_data = row_data.find_next_sibling("td")
            msg["sender"] = row_data.text
            row_data = row_data.find_next_sibling("td")
            msg["reason"] = row_data.text
            row_data = row_data.find_next_sibling("td")
            msg["date"] = row_data.text

            msgs.append(msg)

        return msgs

    def set_held_messages(self, listname: str, action: str, msgs: list[int]):
        """ Set the status for the list of held messages for the supplied listname

            action must be one of 'accept', 'discard', or 'reject'.
        """
        page = self._browser.open(self._baseurl + 'postorius/lists/' + listname + '/held_messages')

        count_select = page.soup.find("select", attrs={'name': 'count'})
        count_form = count_select.parent
        count = 10
        for option in count_select.find_all('option'):
            if 'selected' in option.attrs:
                count = option['value']
        if count != 200:
            count_form = self._browser.select_form(selector=count_form)
            count_form.set_select({'count': 200})
            page = self._browser.submit_selected()

        msg_form = page.soup.find("h2")
        if msg_form.text.strip() != "Held Messages":
            raise HTMLParseError("Couldn't find held message list")
        msg_form = msg_form.find_next_sibling("form")
        msg_form = self._browser.select_form(selector=msg_form)
        msg_form.set_checkbox({'choices': msgs})
        msg_form.choose_submit(action)
        self._browser.submit_selected()


    def get_message(self, listname: str, msg: int) -> dict:
        """ Retrieves a message from a list """
        page = self._browser.open(self._baseurl + 'postorius/api/list/' + listname +
                                  '/held_message/' + str(msg))
        if page.status_code != 200:
            return {}

        return json.loads(page.text)


def getch(allowed_chars="") -> str:
    """ Get a single character from stdin without waiting for enter to be pressed """
    stdin_fd = sys.stdin.fileno()
    orig = termios.tcgetattr(stdin_fd)

    try:
        tty.setcbreak(stdin_fd)
        # pylint: disable=invalid-name
        c = sys.stdin.read(1)
        while allowed_chars != "" and allowed_chars.find(c) == -1:
            c = sys.stdin.read(1)
        print(c, end="")
        return c
    finally:
        termios.tcsetattr(stdin_fd, termios.TCSAFLUSH, orig)


def read_config(filename: str) -> dict:
    """ Reads the config file """

    conf: dict[str, str] = {
        'lists': [], # type: ignore
    }

    # pylint: disable=invalid-name
    with open(filename, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()

            if not line or line[0] == '#':
                continue

            parts = line.split()
            if len(parts) != 2:
                print("Invalid config option:", line)
                sys.exit(1)

            if parts[0] == 'list':
                conf['lists'].append(parts[1]) # type: ignore
            else:
                conf[parts[0]] = parts[1]

    return conf


#pylint: disable=too-many-branches
def moderate_list(mmui: Mailman3UI, listname: str):
    """ Moderate the given list for the supplied Mailman3 web interface

    Retrieves the list of held messages for the list, and displays each in turn to the user.
    The user can then select what to do with the message. Once all messages for the list have
    been dealt with the user is asked to confirm that we should proceed.
    """

    print(f"fetching data for {listname} ... ", end='', flush=True)
    listname.replace('@', '.')
    msgs = mmui.get_held_messages(listname)
    count = len(msgs)
    if count == 0:
        print("nothing in queue")
        return

    print(f"{count} messages")

    todo: dict[str, list[int]] = {
            'accept': [],
            'discard': [],
    }
    i = 0
    while i < len(msgs):
        print(f"({i+1}/{count}) {msgs[i]['id']}: {msgs[i]['sender']} / {msgs[i]['date']}:")
        print(f"  {msgs[i]['reason']}: {msgs[i]['subject']}")
        print("(a)ccept, (d)iscard, (b)ody, (h)eaders, (s)kip, (q)uit? ", end='', flush=True)

        # pylint: disable=invalid-name
        c = getch("abdhqs")
        print()
        if c == 'a':
            todo['accept'].append(msgs[i]['id'])
        elif c == 'b':
            msg = mmui.get_message(listname, msgs[i]['id'])
            curline = 0
            for line in msg['msg']['body'].split('\n'):
                print(f"| {line}")
                curline += 1
                if curline >= 20:
                    break
            continue
        elif c == 'd':
            todo['discard'].append(msgs[i]['id'])
        elif c == 'h':
            msg = mmui.get_message(listname, msgs[i]['id'])
            for line in msg['msg']['headers'].split('\n'):
                print(f"| {line}")
            continue
        elif c == 'q':
            print("Moving on...")
            return
        i+= 1

    if len(todo['accept']) > 0 or len(todo['discard']) > 0:
        print(f"{len(todo['accept'])} to accept, "
              f"{len(todo['discard'])} to discard, "
               "proceed? (y/n) ",
                end='', flush=True)

        # pylint: disable=invalid-name
        c = getch("ny")
        print()
        if c != 'y':
            print("Moving on...")
            return

        if len(todo['accept']) > 0:
            mmui.set_held_messages(listname, 'accept', todo['accept'])
        if len(todo['discard']) > 0:
            mmui.set_held_messages(listname, 'discard', todo['discard'])


def listadmin3():
    """ A command line mailman3 moderator queue tool """
    config = read_config(os.getenv('HOME', '.') + '/.listadmin3.ini')

    webui = Mailman3UI(url=config['base_url'],
                       username=config['username'],
                       password=config['password'])
    webui.login()

    # pylint: disable=invalid-name
    for l in config['lists']:
        moderate_list(webui, l)


if __name__ == '__main__':
    listadmin3()
